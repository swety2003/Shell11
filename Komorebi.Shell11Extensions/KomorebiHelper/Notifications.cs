// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//
//    using Komorebi.Notifications;
//
//    var coordinate = Coordinate.FromJson(jsonString);
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace Komorebi.Notifications;

using System;
using System.Collections.Generic;

using System.Text.Json;
using System.Text.Json.Serialization;
using System.Globalization;

public partial class Coordinate
{
    [JsonPropertyName("event")]
    public NotificationEvent Event { get; set; }

    [JsonPropertyName("state")]
    public State State { get; set; }
}

public partial class NotificationEvent
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("content")]
    public Content? Content { get; set; }

    [JsonPropertyName("type")]
    public TypeEnum Type { get; set; }
}

public partial class PurpleWindow
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("hwnd")]
    public long? Hwnd { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("title")]
    public string? Title { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("exe")]
    public string? Exe { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("class")]
    public string? Class { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("rect")]
    public Rect? Rect { get; set; }

}

public partial class FluffyWindow
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("hwnd")]
    public long? Hwnd { get; set; }

    /// <summary>
    /// The bottom point in a Win32 Rect
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("bottom")]
    public long? Bottom { get; set; }

    /// <summary>
    /// The left point in a Win32 Rect
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("left")]
    public long? Left { get; set; }

    /// <summary>
    /// The right point in a Win32 Rect
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("right")]
    public long? Right { get; set; }

    /// <summary>
    /// The top point in a Win32 Rect
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("top")]
    public long? Top { get; set; }
}

public partial class State
{
    [JsonPropertyName("cross_monitor_move_behaviour")]
    public MoveBehaviour CrossMonitorMoveBehaviour { get; set; }

    [JsonPropertyName("focus_follows_mouse")]
    public FocusFollowsMouseEnum? FocusFollowsMouse { get; set; }

    [JsonPropertyName("has_pending_raise_op")]
    public bool HasPendingRaiseOp { get; set; }

    [JsonPropertyName("is_paused")]
    public bool IsPaused { get; set; }

    [JsonPropertyName("monitors")]
    public RingForMonitor Monitors { get; set; }

    [JsonPropertyName("mouse_follows_focus")]
    public bool MouseFollowsFocus { get; set; }

    [JsonPropertyName("new_window_behaviour")]
    public WindowContainerBehaviour NewWindowBehaviour { get; set; }

    [JsonPropertyName("resize_delta")]
    public long ResizeDelta { get; set; }

    [JsonPropertyName("unmanaged_window_operation_behaviour")]
    public OperationBehaviour UnmanagedWindowOperationBehaviour { get; set; }

    [JsonPropertyName("work_area_offset")]
    public Rect WorkAreaOffset { get; set; }
}

public partial class RingForMonitor
{
    [JsonPropertyName("elements")]
    public List<Monitor> Elements { get; set; }

    [JsonPropertyName("focused")]
    public long Focused { get; set; }
}

public partial class Monitor
{
    [JsonPropertyName("device")]
    public string Device { get; set; }

    [JsonPropertyName("device_id")]
    public string DeviceId { get; set; }

    [JsonPropertyName("id")]
    public long Id { get; set; }

    [JsonPropertyName("last_focused_workspace")]
    public long? LastFocusedWorkspace { get; set; }

    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonPropertyName("size")]
    public Rect Size { get; set; }

    [JsonPropertyName("window_based_work_area_offset")]
    public Rect WindowBasedWorkAreaOffset { get; set; }

    [JsonPropertyName("window_based_work_area_offset_limit")]
    public long WindowBasedWorkAreaOffsetLimit { get; set; }

    [JsonPropertyName("work_area_offset")]
    public Rect WorkAreaOffset { get; set; }

    [JsonPropertyName("work_area_size")]
    public Rect WorkAreaSize { get; set; }

    [JsonPropertyName("workspace_names")]
    public Dictionary<string, string> WorkspaceNames { get; set; }

    [JsonPropertyName("workspaces")]
    public RingForWorkspace Workspaces { get; set; }
}

public partial class Rect
{
    /// <summary>
    /// The bottom point in a Win32 Rect
    /// </summary>
    [JsonPropertyName("bottom")]
    public long Bottom { get; set; }

    /// <summary>
    /// The left point in a Win32 Rect
    /// </summary>
    [JsonPropertyName("left")]
    public long Left { get; set; }

    /// <summary>
    /// The right point in a Win32 Rect
    /// </summary>
    [JsonPropertyName("right")]
    public long Right { get; set; }

    /// <summary>
    /// The top point in a Win32 Rect
    /// </summary>
    [JsonPropertyName("top")]
    public long Top { get; set; }
}

public partial class RingForWorkspace
{
    [JsonPropertyName("elements")]
    public List<Workspace> Elements { get; set; }

    [JsonPropertyName("focused")]
    public long Focused { get; set; }
}

public partial class Workspace
{
    [JsonPropertyName("container_padding")]
    public long? ContainerPadding { get; set; }

    [JsonPropertyName("containers")]
    public RingForContainer Containers { get; set; }

    [JsonPropertyName("floating_windows")]
    public List<Window> FloatingWindows { get; set; }

    [JsonPropertyName("latest_layout")]
    public List<Rect> LatestLayout { get; set; }

    [JsonPropertyName("layout")]
    public Layout Layout { get; set; }

    [JsonPropertyName("layout_flip")]
    public Axis? LayoutFlip { get; set; }

    [JsonPropertyName("layout_rules")]
    public List<List<LayoutRuleElement>> LayoutRules { get; set; }

    [JsonPropertyName("maximized_window")]
    public Window MaximizedWindow { get; set; }

    [JsonPropertyName("maximized_window_restore_idx")]
    public long? MaximizedWindowRestoreIdx { get; set; }

    [JsonPropertyName("monocle_container")]
    public Container MonocleContainer { get; set; }

    [JsonPropertyName("monocle_container_restore_idx")]
    public long? MonocleContainerRestoreIdx { get; set; }

    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonPropertyName("resize_dimensions")]
    public List<Rect> ResizeDimensions { get; set; }

    [JsonPropertyName("tile")]
    public bool Tile { get; set; }

    [JsonPropertyName("workspace_padding")]
    public long? WorkspacePadding { get; set; }
}

public partial class RingForContainer
{
    [JsonPropertyName("elements")]
    public List<Container> Elements { get; set; }

    [JsonPropertyName("focused")]
    public long Focused { get; set; }
}

public partial class Container
{
    [JsonPropertyName("id")]
    public string Id { get; set; }

    [JsonPropertyName("windows")]
    public RingForWindow Windows { get; set; }
}

public partial class RingForWindow
{
    [JsonPropertyName("elements")]
    public List<Window> Elements { get; set; }

    [JsonPropertyName("focused")]
    public long Focused { get; set; }
}

public partial class Window
{
    [JsonPropertyName("hwnd")]
    public long Hwnd { get; set; }
}

public partial class Layout
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("Default")]
    public DefaultLayout? Default { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("Custom")]
    public List<Column> Custom { get; set; }
}

public partial class Column
{
    [JsonPropertyName("column")]
    public ColumnEnum ColumnColumn { get; set; }

    [JsonPropertyName("configuration")]
    public ColumnSplitWithCapacity Configuration { get; set; }
}

public partial class ColumnWidth
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("WidthPercentage")]
    public double? WidthPercentage { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("Horizontal")]
    public long? Horizontal { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("Vertical")]
    public long? Vertical { get; set; }
}

public partial class LayoutRuleClass
{
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("Default")]
    public DefaultLayout? Default { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("Custom")]
    public List<Column> Custom { get; set; }
}

public enum TypeEnum { AddSubscriberPipe, AddSubscriberSocket, AdjustContainerPadding, AdjustWorkspacePadding, AltFocusHack, ApplicationSpecificConfigurationSchema, Border, BorderColour, BorderOffset, BorderStyle, BorderWidth, ChangeLayout, ChangeLayoutCustom, ClearNamedWorkspaceLayoutRules, ClearWorkspaceLayoutRules, Cloak, Close, CompleteConfiguration, ContainerPadding, CrossMonitorMoveBehaviour, CycleFocusMonitor, CycleFocusWindow, CycleFocusWorkspace, CycleLayout, CycleMoveContainerToMonitor, CycleMoveContainerToWorkspace, CycleMoveWindow, CycleMoveWorkspaceToMonitor, CycleSendContainerToMonitor, CycleSendContainerToWorkspace, CycleStack, DebugWindow, Destroy, DisplayIndexPreference, EnsureNamedWorkspaces, EnsureWorkspaces, FlipLayout, FloatRule, FocusChange, FocusFollowsMouse, FocusLastWorkspace, FocusMonitorNumber, FocusMonitorWorkspaceNumber, FocusNamedWorkspace, FocusWindow, FocusWorkspaceNumber, FocusWorkspaceNumbers, FocusedWorkspaceContainerPadding, FocusedWorkspacePadding, ForceFocus, GenerateStaticConfig, GlobalState, Hide, IdentifyBorderOverflowApplication, IdentifyLayeredApplication, IdentifyObjectNameChangeApplication, IdentifyTrayApplication, InitialNamedWorkspaceRule, InitialWorkspaceRule, InvisibleBorders, Load, Manage, ManageFocusedWindow, ManageRule, Minimize, MonitorIndexPreference, MonitorInformation, MonitorWorkAreaOffset, MouseCapture, MouseFollowsFocus, MoveContainerToMonitorNumber, MoveContainerToMonitorWorkspaceNumber, MoveContainerToNamedWorkspace, MoveContainerToWorkspaceNumber, MoveResizeEnd, MoveResizeStart, MoveWindow, MoveWorkspaceToMonitorNumber, NamedWorkspaceContainerPadding, NamedWorkspaceLayout, NamedWorkspaceLayoutCustom, NamedWorkspaceLayoutCustomRule, NamedWorkspaceLayoutRule, NamedWorkspacePadding, NamedWorkspaceRule, NamedWorkspaceTiling, NewWorkspace, NotificationSchema, Promote, PromoteFocus, PromoteWindow, Query, QuickLoad, QuickSave, Raise, ReloadConfiguration, ReloadStaticConfiguration, RemoveSubscriberPipe, RemoveSubscriberSocket, RemoveTitleBar, ResizeDelta, ResizeWindowAxis, ResizeWindowEdge, Retile, Save, SendContainerToMonitorNumber, SendContainerToMonitorWorkspaceNumber, SendContainerToNamedWorkspace, SendContainerToWorkspaceNumber, Show, SocketSchema, StackAll, StackWindow, StackbarBackgroundColour, StackbarFocusedTextColour, StackbarHeight, StackbarLabel, StackbarMode, StackbarTabWidth, StackbarUnfocusedTextColour, State, StaticConfigSchema, Stop, SwapWorkspacesToMonitorNumber, TitleUpdate, ToggleCrossMonitorMoveBehaviour, ToggleFloat, ToggleFocusFollowsMouse, ToggleMaximize, ToggleMonocle, ToggleMouseFollowsFocus, TogglePause, ToggleTiling, ToggleTitleBars, ToggleWindowContainerBehaviour, Transparency, TransparencyAlpha, Uncloak, Unmanage, UnmanageFocusedWindow, UnmanagedWindowOperationBehaviour, UnstackAll, UnstackWindow, VisibleWindows, WatchConfiguration, WindowHidingBehaviour, WorkAreaOffset, WorkspaceLayout, WorkspaceLayoutCustom, WorkspaceLayoutCustomRule, WorkspaceLayoutRule, WorkspaceName, WorkspacePadding, WorkspaceRule, WorkspaceTiling };

/// <summary>
/// Swap the window container with the window container at the edge of the adjacent monitor
///
/// Insert the window container into the focused workspace on the adjacent monitor
///
/// Do nothing if trying to move a window container in the direction of an adjacent monitor
/// </summary>
public enum MoveBehaviour { Insert, NoOp, Swap };

/// <summary>
/// A custom FFM implementation (slightly more CPU-intensive)
///
/// The native (legacy) Windows FFM implementation
/// </summary>
public enum FocusFollowsMouseEnum { Komorebi, Windows };

public enum ColumnEnum { Primary, Secondary, Tertiary };

public enum ColumnSplit { Horizontal, Vertical };

public enum DefaultLayout { BSP, Columns, Grid, HorizontalStack, RightMainVerticalStack, Rows, UltrawideVerticalStack, VerticalStack };

public enum Axis { Horizontal, HorizontalAndVertical, Vertical };

/// <summary>
/// Create a new container for each new window
///
/// Append new windows to the focused window container
/// </summary>
public enum WindowContainerBehaviour { Append, Create };

/// <summary>
/// Process komorebic commands on temporarily unmanaged/floated windows
///
/// Ignore komorebic commands on temporarily unmanaged/floated windows
/// </summary>
public enum OperationBehaviour { NoOp, Op };

public partial struct ContentElement
{
    public bool? Bool;
    public long? Integer;
    public PurpleWindow PurpleWindow;
    public string String;
    public List<string> StringArray;

    public static implicit operator ContentElement(bool Bool) => new ContentElement { Bool = Bool };
    public static implicit operator ContentElement(long Integer) => new ContentElement { Integer = Integer };
    public static implicit operator ContentElement(PurpleWindow PurpleWindow) => new ContentElement { PurpleWindow = PurpleWindow };
    public static implicit operator ContentElement(string String) => new ContentElement { String = String };
    public static implicit operator ContentElement(List<string> StringArray) => new ContentElement { StringArray = StringArray };
}

public partial struct Content
{
    public List<ContentElement> AnythingArray;
    public bool? Bool;
    public FluffyWindow FluffyWindow;
    public long? Integer;
    public string String;

    public static implicit operator Content(List<ContentElement> AnythingArray) => new Content { AnythingArray = AnythingArray };
    public static implicit operator Content(bool Bool) => new Content { Bool = Bool };
    public static implicit operator Content(FluffyWindow FluffyWindow) => new Content { FluffyWindow = FluffyWindow };
    public static implicit operator Content(long Integer) => new Content { Integer = Integer };
    public static implicit operator Content(string String) => new Content { String = String };
}

public partial struct ColumnSplitWithCapacity
{
    public ColumnWidth ColumnWidth;
    public ColumnSplit? Enum;

    public static implicit operator ColumnSplitWithCapacity(ColumnWidth ColumnWidth) => new ColumnSplitWithCapacity { ColumnWidth = ColumnWidth };
    public static implicit operator ColumnSplitWithCapacity(ColumnSplit Enum) => new ColumnSplitWithCapacity { Enum = Enum };
    public bool IsNull => ColumnWidth == null && Enum == null;
}

public partial struct LayoutRuleElement
{
    public long? Integer;
    public LayoutRuleClass LayoutRuleClass;

    public static implicit operator LayoutRuleElement(long Integer) => new LayoutRuleElement { Integer = Integer };
    public static implicit operator LayoutRuleElement(LayoutRuleClass LayoutRuleClass) => new LayoutRuleElement { LayoutRuleClass = LayoutRuleClass };
}

public partial class Coordinate
{
    public static Coordinate FromJson(string json) => JsonSerializer.Deserialize<Coordinate>(json, Komorebi.Notifications.Converter.Settings);
}

public static class Serialize
{
    public static string ToJson(this Coordinate self) => JsonSerializer.Serialize(self, Komorebi.Notifications.Converter.Settings);
}

internal static class Converter
{
    public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
    {
        Converters =
        {
            ContentConverter.Singleton,
            ContentElementConverter.Singleton,
            TypeEnumConverter.Singleton,
            MoveBehaviourConverter.Singleton,
            FocusFollowsMouseEnumConverter.Singleton,
            ColumnEnumConverter.Singleton,
            ColumnSplitWithCapacityConverter.Singleton,
            ColumnSplitConverter.Singleton,
            DefaultLayoutConverter.Singleton,
            AxisConverter.Singleton,
            LayoutRuleElementConverter.Singleton,
            WindowContainerBehaviourConverter.Singleton,
            OperationBehaviourConverter.Singleton,
            new DateOnlyConverter(),
            new TimeOnlyConverter(),
            IsoDateTimeOffsetConverter.Singleton
        },
    };
}

internal class ContentConverter : JsonConverter<Content>
{
    public override bool CanConvert(Type t) => t == typeof(Content);

    public override Content Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.Number:
                var integerValue = reader.GetInt64();
                return new Content { Integer = integerValue };
            case JsonTokenType.True:
            case JsonTokenType.False:
                var boolValue = reader.GetBoolean();
                return new Content { Bool = boolValue };
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new Content { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<FluffyWindow>(ref reader, options);
                return new Content { FluffyWindow = objectValue };
            case JsonTokenType.StartArray:
                var arrayValue = JsonSerializer.Deserialize<List<ContentElement>>(ref reader, options);
                return new Content { AnythingArray = arrayValue };
        }
        throw new Exception("Cannot unmarshal type Content");
    }

    public override void Write(Utf8JsonWriter writer, Content value, JsonSerializerOptions options)
    {
        if (value.Integer != null)
        {
            JsonSerializer.Serialize(writer, value.Integer.Value, options);
            return;
        }
        if (value.Bool != null)
        {
            JsonSerializer.Serialize(writer, value.Bool.Value, options);
            return;
        }
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.AnythingArray != null)
        {
            JsonSerializer.Serialize(writer, value.AnythingArray, options);
            return;
        }
        if (value.FluffyWindow != null)
        {
            JsonSerializer.Serialize(writer, value.FluffyWindow, options);
            return;
        }
        throw new Exception("Cannot marshal type Content");
    }

    public static readonly ContentConverter Singleton = new ContentConverter();
}

internal class ContentElementConverter : JsonConverter<ContentElement>
{
    public override bool CanConvert(Type t) => t == typeof(ContentElement);

    public override ContentElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.Number:
                var integerValue = reader.GetInt64();
                return new ContentElement { Integer = integerValue };
            case JsonTokenType.True:
            case JsonTokenType.False:
                var boolValue = reader.GetBoolean();
                return new ContentElement { Bool = boolValue };
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                return new ContentElement { String = stringValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<PurpleWindow>(ref reader, options);
                return new ContentElement { PurpleWindow = objectValue };
            case JsonTokenType.StartArray:
                var arrayValue = JsonSerializer.Deserialize<List<string>>(ref reader, options);
                return new ContentElement { StringArray = arrayValue };
        }
        throw new Exception("Cannot unmarshal type ContentElement");
    }

    public override void Write(Utf8JsonWriter writer, ContentElement value, JsonSerializerOptions options)
    {
        if (value.Integer != null)
        {
            JsonSerializer.Serialize(writer, value.Integer.Value, options);
            return;
        }
        if (value.Bool != null)
        {
            JsonSerializer.Serialize(writer, value.Bool.Value, options);
            return;
        }
        if (value.String != null)
        {
            JsonSerializer.Serialize(writer, value.String, options);
            return;
        }
        if (value.StringArray != null)
        {
            JsonSerializer.Serialize(writer, value.StringArray, options);
            return;
        }
        if (value.PurpleWindow != null)
        {
            JsonSerializer.Serialize(writer, value.PurpleWindow, options);
            return;
        }
        throw new Exception("Cannot marshal type ContentElement");
    }

    public static readonly ContentElementConverter Singleton = new ContentElementConverter();
}

internal class TypeEnumConverter : JsonConverter<TypeEnum>
{
    public override bool CanConvert(Type t) => t == typeof(TypeEnum);

    public override TypeEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "AddSubscriberPipe":
                return TypeEnum.AddSubscriberPipe;
            case "AddSubscriberSocket":
                return TypeEnum.AddSubscriberSocket;
            case "AdjustContainerPadding":
                return TypeEnum.AdjustContainerPadding;
            case "AdjustWorkspacePadding":
                return TypeEnum.AdjustWorkspacePadding;
            case "AltFocusHack":
                return TypeEnum.AltFocusHack;
            case "ApplicationSpecificConfigurationSchema":
                return TypeEnum.ApplicationSpecificConfigurationSchema;
            case "Border":
                return TypeEnum.Border;
            case "BorderColour":
                return TypeEnum.BorderColour;
            case "BorderOffset":
                return TypeEnum.BorderOffset;
            case "BorderStyle":
                return TypeEnum.BorderStyle;
            case "BorderWidth":
                return TypeEnum.BorderWidth;
            case "ChangeLayout":
                return TypeEnum.ChangeLayout;
            case "ChangeLayoutCustom":
                return TypeEnum.ChangeLayoutCustom;
            case "ClearNamedWorkspaceLayoutRules":
                return TypeEnum.ClearNamedWorkspaceLayoutRules;
            case "ClearWorkspaceLayoutRules":
                return TypeEnum.ClearWorkspaceLayoutRules;
            case "Cloak":
                return TypeEnum.Cloak;
            case "Close":
                return TypeEnum.Close;
            case "CompleteConfiguration":
                return TypeEnum.CompleteConfiguration;
            case "ContainerPadding":
                return TypeEnum.ContainerPadding;
            case "CrossMonitorMoveBehaviour":
                return TypeEnum.CrossMonitorMoveBehaviour;
            case "CycleFocusMonitor":
                return TypeEnum.CycleFocusMonitor;
            case "CycleFocusWindow":
                return TypeEnum.CycleFocusWindow;
            case "CycleFocusWorkspace":
                return TypeEnum.CycleFocusWorkspace;
            case "CycleLayout":
                return TypeEnum.CycleLayout;
            case "CycleMoveContainerToMonitor":
                return TypeEnum.CycleMoveContainerToMonitor;
            case "CycleMoveContainerToWorkspace":
                return TypeEnum.CycleMoveContainerToWorkspace;
            case "CycleMoveWindow":
                return TypeEnum.CycleMoveWindow;
            case "CycleMoveWorkspaceToMonitor":
                return TypeEnum.CycleMoveWorkspaceToMonitor;
            case "CycleSendContainerToMonitor":
                return TypeEnum.CycleSendContainerToMonitor;
            case "CycleSendContainerToWorkspace":
                return TypeEnum.CycleSendContainerToWorkspace;
            case "CycleStack":
                return TypeEnum.CycleStack;
            case "DebugWindow":
                return TypeEnum.DebugWindow;
            case "Destroy":
                return TypeEnum.Destroy;
            case "DisplayIndexPreference":
                return TypeEnum.DisplayIndexPreference;
            case "EnsureNamedWorkspaces":
                return TypeEnum.EnsureNamedWorkspaces;
            case "EnsureWorkspaces":
                return TypeEnum.EnsureWorkspaces;
            case "FlipLayout":
                return TypeEnum.FlipLayout;
            case "FloatRule":
                return TypeEnum.FloatRule;
            case "FocusChange":
                return TypeEnum.FocusChange;
            case "FocusFollowsMouse":
                return TypeEnum.FocusFollowsMouse;
            case "FocusLastWorkspace":
                return TypeEnum.FocusLastWorkspace;
            case "FocusMonitorNumber":
                return TypeEnum.FocusMonitorNumber;
            case "FocusMonitorWorkspaceNumber":
                return TypeEnum.FocusMonitorWorkspaceNumber;
            case "FocusNamedWorkspace":
                return TypeEnum.FocusNamedWorkspace;
            case "FocusWindow":
                return TypeEnum.FocusWindow;
            case "FocusWorkspaceNumber":
                return TypeEnum.FocusWorkspaceNumber;
            case "FocusWorkspaceNumbers":
                return TypeEnum.FocusWorkspaceNumbers;
            case "FocusedWorkspaceContainerPadding":
                return TypeEnum.FocusedWorkspaceContainerPadding;
            case "FocusedWorkspacePadding":
                return TypeEnum.FocusedWorkspacePadding;
            case "ForceFocus":
                return TypeEnum.ForceFocus;
            case "GenerateStaticConfig":
                return TypeEnum.GenerateStaticConfig;
            case "GlobalState":
                return TypeEnum.GlobalState;
            case "Hide":
                return TypeEnum.Hide;
            case "IdentifyBorderOverflowApplication":
                return TypeEnum.IdentifyBorderOverflowApplication;
            case "IdentifyLayeredApplication":
                return TypeEnum.IdentifyLayeredApplication;
            case "IdentifyObjectNameChangeApplication":
                return TypeEnum.IdentifyObjectNameChangeApplication;
            case "IdentifyTrayApplication":
                return TypeEnum.IdentifyTrayApplication;
            case "InitialNamedWorkspaceRule":
                return TypeEnum.InitialNamedWorkspaceRule;
            case "InitialWorkspaceRule":
                return TypeEnum.InitialWorkspaceRule;
            case "InvisibleBorders":
                return TypeEnum.InvisibleBorders;
            case "Load":
                return TypeEnum.Load;
            case "Manage":
                return TypeEnum.Manage;
            case "ManageFocusedWindow":
                return TypeEnum.ManageFocusedWindow;
            case "ManageRule":
                return TypeEnum.ManageRule;
            case "Minimize":
                return TypeEnum.Minimize;
            case "MonitorIndexPreference":
                return TypeEnum.MonitorIndexPreference;
            case "MonitorInformation":
                return TypeEnum.MonitorInformation;
            case "MonitorWorkAreaOffset":
                return TypeEnum.MonitorWorkAreaOffset;
            case "MouseCapture":
                return TypeEnum.MouseCapture;
            case "MouseFollowsFocus":
                return TypeEnum.MouseFollowsFocus;
            case "MoveContainerToMonitorNumber":
                return TypeEnum.MoveContainerToMonitorNumber;
            case "MoveContainerToMonitorWorkspaceNumber":
                return TypeEnum.MoveContainerToMonitorWorkspaceNumber;
            case "MoveContainerToNamedWorkspace":
                return TypeEnum.MoveContainerToNamedWorkspace;
            case "MoveContainerToWorkspaceNumber":
                return TypeEnum.MoveContainerToWorkspaceNumber;
            case "MoveResizeEnd":
                return TypeEnum.MoveResizeEnd;
            case "MoveResizeStart":
                return TypeEnum.MoveResizeStart;
            case "MoveWindow":
                return TypeEnum.MoveWindow;
            case "MoveWorkspaceToMonitorNumber":
                return TypeEnum.MoveWorkspaceToMonitorNumber;
            case "NamedWorkspaceContainerPadding":
                return TypeEnum.NamedWorkspaceContainerPadding;
            case "NamedWorkspaceLayout":
                return TypeEnum.NamedWorkspaceLayout;
            case "NamedWorkspaceLayoutCustom":
                return TypeEnum.NamedWorkspaceLayoutCustom;
            case "NamedWorkspaceLayoutCustomRule":
                return TypeEnum.NamedWorkspaceLayoutCustomRule;
            case "NamedWorkspaceLayoutRule":
                return TypeEnum.NamedWorkspaceLayoutRule;
            case "NamedWorkspacePadding":
                return TypeEnum.NamedWorkspacePadding;
            case "NamedWorkspaceRule":
                return TypeEnum.NamedWorkspaceRule;
            case "NamedWorkspaceTiling":
                return TypeEnum.NamedWorkspaceTiling;
            case "NewWorkspace":
                return TypeEnum.NewWorkspace;
            case "NotificationSchema":
                return TypeEnum.NotificationSchema;
            case "Promote":
                return TypeEnum.Promote;
            case "PromoteFocus":
                return TypeEnum.PromoteFocus;
            case "PromoteWindow":
                return TypeEnum.PromoteWindow;
            case "Query":
                return TypeEnum.Query;
            case "QuickLoad":
                return TypeEnum.QuickLoad;
            case "QuickSave":
                return TypeEnum.QuickSave;
            case "Raise":
                return TypeEnum.Raise;
            case "ReloadConfiguration":
                return TypeEnum.ReloadConfiguration;
            case "ReloadStaticConfiguration":
                return TypeEnum.ReloadStaticConfiguration;
            case "RemoveSubscriberPipe":
                return TypeEnum.RemoveSubscriberPipe;
            case "RemoveSubscriberSocket":
                return TypeEnum.RemoveSubscriberSocket;
            case "RemoveTitleBar":
                return TypeEnum.RemoveTitleBar;
            case "ResizeDelta":
                return TypeEnum.ResizeDelta;
            case "ResizeWindowAxis":
                return TypeEnum.ResizeWindowAxis;
            case "ResizeWindowEdge":
                return TypeEnum.ResizeWindowEdge;
            case "Retile":
                return TypeEnum.Retile;
            case "Save":
                return TypeEnum.Save;
            case "SendContainerToMonitorNumber":
                return TypeEnum.SendContainerToMonitorNumber;
            case "SendContainerToMonitorWorkspaceNumber":
                return TypeEnum.SendContainerToMonitorWorkspaceNumber;
            case "SendContainerToNamedWorkspace":
                return TypeEnum.SendContainerToNamedWorkspace;
            case "SendContainerToWorkspaceNumber":
                return TypeEnum.SendContainerToWorkspaceNumber;
            case "Show":
                return TypeEnum.Show;
            case "SocketSchema":
                return TypeEnum.SocketSchema;
            case "StackAll":
                return TypeEnum.StackAll;
            case "StackWindow":
                return TypeEnum.StackWindow;
            case "StackbarBackgroundColour":
                return TypeEnum.StackbarBackgroundColour;
            case "StackbarFocusedTextColour":
                return TypeEnum.StackbarFocusedTextColour;
            case "StackbarHeight":
                return TypeEnum.StackbarHeight;
            case "StackbarLabel":
                return TypeEnum.StackbarLabel;
            case "StackbarMode":
                return TypeEnum.StackbarMode;
            case "StackbarTabWidth":
                return TypeEnum.StackbarTabWidth;
            case "StackbarUnfocusedTextColour":
                return TypeEnum.StackbarUnfocusedTextColour;
            case "State":
                return TypeEnum.State;
            case "StaticConfigSchema":
                return TypeEnum.StaticConfigSchema;
            case "Stop":
                return TypeEnum.Stop;
            case "SwapWorkspacesToMonitorNumber":
                return TypeEnum.SwapWorkspacesToMonitorNumber;
            case "TitleUpdate":
                return TypeEnum.TitleUpdate;
            case "ToggleCrossMonitorMoveBehaviour":
                return TypeEnum.ToggleCrossMonitorMoveBehaviour;
            case "ToggleFloat":
                return TypeEnum.ToggleFloat;
            case "ToggleFocusFollowsMouse":
                return TypeEnum.ToggleFocusFollowsMouse;
            case "ToggleMaximize":
                return TypeEnum.ToggleMaximize;
            case "ToggleMonocle":
                return TypeEnum.ToggleMonocle;
            case "ToggleMouseFollowsFocus":
                return TypeEnum.ToggleMouseFollowsFocus;
            case "TogglePause":
                return TypeEnum.TogglePause;
            case "ToggleTiling":
                return TypeEnum.ToggleTiling;
            case "ToggleTitleBars":
                return TypeEnum.ToggleTitleBars;
            case "ToggleWindowContainerBehaviour":
                return TypeEnum.ToggleWindowContainerBehaviour;
            case "Transparency":
                return TypeEnum.Transparency;
            case "TransparencyAlpha":
                return TypeEnum.TransparencyAlpha;
            case "Uncloak":
                return TypeEnum.Uncloak;
            case "Unmanage":
                return TypeEnum.Unmanage;
            case "UnmanageFocusedWindow":
                return TypeEnum.UnmanageFocusedWindow;
            case "UnmanagedWindowOperationBehaviour":
                return TypeEnum.UnmanagedWindowOperationBehaviour;
            case "UnstackAll":
                return TypeEnum.UnstackAll;
            case "UnstackWindow":
                return TypeEnum.UnstackWindow;
            case "VisibleWindows":
                return TypeEnum.VisibleWindows;
            case "WatchConfiguration":
                return TypeEnum.WatchConfiguration;
            case "WindowHidingBehaviour":
                return TypeEnum.WindowHidingBehaviour;
            case "WorkAreaOffset":
                return TypeEnum.WorkAreaOffset;
            case "WorkspaceLayout":
                return TypeEnum.WorkspaceLayout;
            case "WorkspaceLayoutCustom":
                return TypeEnum.WorkspaceLayoutCustom;
            case "WorkspaceLayoutCustomRule":
                return TypeEnum.WorkspaceLayoutCustomRule;
            case "WorkspaceLayoutRule":
                return TypeEnum.WorkspaceLayoutRule;
            case "WorkspaceName":
                return TypeEnum.WorkspaceName;
            case "WorkspacePadding":
                return TypeEnum.WorkspacePadding;
            case "WorkspaceRule":
                return TypeEnum.WorkspaceRule;
            case "WorkspaceTiling":
                return TypeEnum.WorkspaceTiling;
        }
        throw new Exception("Cannot unmarshal type TypeEnum");
    }

    public override void Write(Utf8JsonWriter writer, TypeEnum value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case TypeEnum.AddSubscriberPipe:
                JsonSerializer.Serialize(writer, "AddSubscriberPipe", options);
                return;
            case TypeEnum.AddSubscriberSocket:
                JsonSerializer.Serialize(writer, "AddSubscriberSocket", options);
                return;
            case TypeEnum.AdjustContainerPadding:
                JsonSerializer.Serialize(writer, "AdjustContainerPadding", options);
                return;
            case TypeEnum.AdjustWorkspacePadding:
                JsonSerializer.Serialize(writer, "AdjustWorkspacePadding", options);
                return;
            case TypeEnum.AltFocusHack:
                JsonSerializer.Serialize(writer, "AltFocusHack", options);
                return;
            case TypeEnum.ApplicationSpecificConfigurationSchema:
                JsonSerializer.Serialize(writer, "ApplicationSpecificConfigurationSchema", options);
                return;
            case TypeEnum.Border:
                JsonSerializer.Serialize(writer, "Border", options);
                return;
            case TypeEnum.BorderColour:
                JsonSerializer.Serialize(writer, "BorderColour", options);
                return;
            case TypeEnum.BorderOffset:
                JsonSerializer.Serialize(writer, "BorderOffset", options);
                return;
            case TypeEnum.BorderStyle:
                JsonSerializer.Serialize(writer, "BorderStyle", options);
                return;
            case TypeEnum.BorderWidth:
                JsonSerializer.Serialize(writer, "BorderWidth", options);
                return;
            case TypeEnum.ChangeLayout:
                JsonSerializer.Serialize(writer, "ChangeLayout", options);
                return;
            case TypeEnum.ChangeLayoutCustom:
                JsonSerializer.Serialize(writer, "ChangeLayoutCustom", options);
                return;
            case TypeEnum.ClearNamedWorkspaceLayoutRules:
                JsonSerializer.Serialize(writer, "ClearNamedWorkspaceLayoutRules", options);
                return;
            case TypeEnum.ClearWorkspaceLayoutRules:
                JsonSerializer.Serialize(writer, "ClearWorkspaceLayoutRules", options);
                return;
            case TypeEnum.Cloak:
                JsonSerializer.Serialize(writer, "Cloak", options);
                return;
            case TypeEnum.Close:
                JsonSerializer.Serialize(writer, "Close", options);
                return;
            case TypeEnum.CompleteConfiguration:
                JsonSerializer.Serialize(writer, "CompleteConfiguration", options);
                return;
            case TypeEnum.ContainerPadding:
                JsonSerializer.Serialize(writer, "ContainerPadding", options);
                return;
            case TypeEnum.CrossMonitorMoveBehaviour:
                JsonSerializer.Serialize(writer, "CrossMonitorMoveBehaviour", options);
                return;
            case TypeEnum.CycleFocusMonitor:
                JsonSerializer.Serialize(writer, "CycleFocusMonitor", options);
                return;
            case TypeEnum.CycleFocusWindow:
                JsonSerializer.Serialize(writer, "CycleFocusWindow", options);
                return;
            case TypeEnum.CycleFocusWorkspace:
                JsonSerializer.Serialize(writer, "CycleFocusWorkspace", options);
                return;
            case TypeEnum.CycleLayout:
                JsonSerializer.Serialize(writer, "CycleLayout", options);
                return;
            case TypeEnum.CycleMoveContainerToMonitor:
                JsonSerializer.Serialize(writer, "CycleMoveContainerToMonitor", options);
                return;
            case TypeEnum.CycleMoveContainerToWorkspace:
                JsonSerializer.Serialize(writer, "CycleMoveContainerToWorkspace", options);
                return;
            case TypeEnum.CycleMoveWindow:
                JsonSerializer.Serialize(writer, "CycleMoveWindow", options);
                return;
            case TypeEnum.CycleMoveWorkspaceToMonitor:
                JsonSerializer.Serialize(writer, "CycleMoveWorkspaceToMonitor", options);
                return;
            case TypeEnum.CycleSendContainerToMonitor:
                JsonSerializer.Serialize(writer, "CycleSendContainerToMonitor", options);
                return;
            case TypeEnum.CycleSendContainerToWorkspace:
                JsonSerializer.Serialize(writer, "CycleSendContainerToWorkspace", options);
                return;
            case TypeEnum.CycleStack:
                JsonSerializer.Serialize(writer, "CycleStack", options);
                return;
            case TypeEnum.DebugWindow:
                JsonSerializer.Serialize(writer, "DebugWindow", options);
                return;
            case TypeEnum.Destroy:
                JsonSerializer.Serialize(writer, "Destroy", options);
                return;
            case TypeEnum.DisplayIndexPreference:
                JsonSerializer.Serialize(writer, "DisplayIndexPreference", options);
                return;
            case TypeEnum.EnsureNamedWorkspaces:
                JsonSerializer.Serialize(writer, "EnsureNamedWorkspaces", options);
                return;
            case TypeEnum.EnsureWorkspaces:
                JsonSerializer.Serialize(writer, "EnsureWorkspaces", options);
                return;
            case TypeEnum.FlipLayout:
                JsonSerializer.Serialize(writer, "FlipLayout", options);
                return;
            case TypeEnum.FloatRule:
                JsonSerializer.Serialize(writer, "FloatRule", options);
                return;
            case TypeEnum.FocusChange:
                JsonSerializer.Serialize(writer, "FocusChange", options);
                return;
            case TypeEnum.FocusFollowsMouse:
                JsonSerializer.Serialize(writer, "FocusFollowsMouse", options);
                return;
            case TypeEnum.FocusLastWorkspace:
                JsonSerializer.Serialize(writer, "FocusLastWorkspace", options);
                return;
            case TypeEnum.FocusMonitorNumber:
                JsonSerializer.Serialize(writer, "FocusMonitorNumber", options);
                return;
            case TypeEnum.FocusMonitorWorkspaceNumber:
                JsonSerializer.Serialize(writer, "FocusMonitorWorkspaceNumber", options);
                return;
            case TypeEnum.FocusNamedWorkspace:
                JsonSerializer.Serialize(writer, "FocusNamedWorkspace", options);
                return;
            case TypeEnum.FocusWindow:
                JsonSerializer.Serialize(writer, "FocusWindow", options);
                return;
            case TypeEnum.FocusWorkspaceNumber:
                JsonSerializer.Serialize(writer, "FocusWorkspaceNumber", options);
                return;
            case TypeEnum.FocusWorkspaceNumbers:
                JsonSerializer.Serialize(writer, "FocusWorkspaceNumbers", options);
                return;
            case TypeEnum.FocusedWorkspaceContainerPadding:
                JsonSerializer.Serialize(writer, "FocusedWorkspaceContainerPadding", options);
                return;
            case TypeEnum.FocusedWorkspacePadding:
                JsonSerializer.Serialize(writer, "FocusedWorkspacePadding", options);
                return;
            case TypeEnum.ForceFocus:
                JsonSerializer.Serialize(writer, "ForceFocus", options);
                return;
            case TypeEnum.GenerateStaticConfig:
                JsonSerializer.Serialize(writer, "GenerateStaticConfig", options);
                return;
            case TypeEnum.GlobalState:
                JsonSerializer.Serialize(writer, "GlobalState", options);
                return;
            case TypeEnum.Hide:
                JsonSerializer.Serialize(writer, "Hide", options);
                return;
            case TypeEnum.IdentifyBorderOverflowApplication:
                JsonSerializer.Serialize(writer, "IdentifyBorderOverflowApplication", options);
                return;
            case TypeEnum.IdentifyLayeredApplication:
                JsonSerializer.Serialize(writer, "IdentifyLayeredApplication", options);
                return;
            case TypeEnum.IdentifyObjectNameChangeApplication:
                JsonSerializer.Serialize(writer, "IdentifyObjectNameChangeApplication", options);
                return;
            case TypeEnum.IdentifyTrayApplication:
                JsonSerializer.Serialize(writer, "IdentifyTrayApplication", options);
                return;
            case TypeEnum.InitialNamedWorkspaceRule:
                JsonSerializer.Serialize(writer, "InitialNamedWorkspaceRule", options);
                return;
            case TypeEnum.InitialWorkspaceRule:
                JsonSerializer.Serialize(writer, "InitialWorkspaceRule", options);
                return;
            case TypeEnum.InvisibleBorders:
                JsonSerializer.Serialize(writer, "InvisibleBorders", options);
                return;
            case TypeEnum.Load:
                JsonSerializer.Serialize(writer, "Load", options);
                return;
            case TypeEnum.Manage:
                JsonSerializer.Serialize(writer, "Manage", options);
                return;
            case TypeEnum.ManageFocusedWindow:
                JsonSerializer.Serialize(writer, "ManageFocusedWindow", options);
                return;
            case TypeEnum.ManageRule:
                JsonSerializer.Serialize(writer, "ManageRule", options);
                return;
            case TypeEnum.Minimize:
                JsonSerializer.Serialize(writer, "Minimize", options);
                return;
            case TypeEnum.MonitorIndexPreference:
                JsonSerializer.Serialize(writer, "MonitorIndexPreference", options);
                return;
            case TypeEnum.MonitorInformation:
                JsonSerializer.Serialize(writer, "MonitorInformation", options);
                return;
            case TypeEnum.MonitorWorkAreaOffset:
                JsonSerializer.Serialize(writer, "MonitorWorkAreaOffset", options);
                return;
            case TypeEnum.MouseCapture:
                JsonSerializer.Serialize(writer, "MouseCapture", options);
                return;
            case TypeEnum.MouseFollowsFocus:
                JsonSerializer.Serialize(writer, "MouseFollowsFocus", options);
                return;
            case TypeEnum.MoveContainerToMonitorNumber:
                JsonSerializer.Serialize(writer, "MoveContainerToMonitorNumber", options);
                return;
            case TypeEnum.MoveContainerToMonitorWorkspaceNumber:
                JsonSerializer.Serialize(writer, "MoveContainerToMonitorWorkspaceNumber", options);
                return;
            case TypeEnum.MoveContainerToNamedWorkspace:
                JsonSerializer.Serialize(writer, "MoveContainerToNamedWorkspace", options);
                return;
            case TypeEnum.MoveContainerToWorkspaceNumber:
                JsonSerializer.Serialize(writer, "MoveContainerToWorkspaceNumber", options);
                return;
            case TypeEnum.MoveResizeEnd:
                JsonSerializer.Serialize(writer, "MoveResizeEnd", options);
                return;
            case TypeEnum.MoveResizeStart:
                JsonSerializer.Serialize(writer, "MoveResizeStart", options);
                return;
            case TypeEnum.MoveWindow:
                JsonSerializer.Serialize(writer, "MoveWindow", options);
                return;
            case TypeEnum.MoveWorkspaceToMonitorNumber:
                JsonSerializer.Serialize(writer, "MoveWorkspaceToMonitorNumber", options);
                return;
            case TypeEnum.NamedWorkspaceContainerPadding:
                JsonSerializer.Serialize(writer, "NamedWorkspaceContainerPadding", options);
                return;
            case TypeEnum.NamedWorkspaceLayout:
                JsonSerializer.Serialize(writer, "NamedWorkspaceLayout", options);
                return;
            case TypeEnum.NamedWorkspaceLayoutCustom:
                JsonSerializer.Serialize(writer, "NamedWorkspaceLayoutCustom", options);
                return;
            case TypeEnum.NamedWorkspaceLayoutCustomRule:
                JsonSerializer.Serialize(writer, "NamedWorkspaceLayoutCustomRule", options);
                return;
            case TypeEnum.NamedWorkspaceLayoutRule:
                JsonSerializer.Serialize(writer, "NamedWorkspaceLayoutRule", options);
                return;
            case TypeEnum.NamedWorkspacePadding:
                JsonSerializer.Serialize(writer, "NamedWorkspacePadding", options);
                return;
            case TypeEnum.NamedWorkspaceRule:
                JsonSerializer.Serialize(writer, "NamedWorkspaceRule", options);
                return;
            case TypeEnum.NamedWorkspaceTiling:
                JsonSerializer.Serialize(writer, "NamedWorkspaceTiling", options);
                return;
            case TypeEnum.NewWorkspace:
                JsonSerializer.Serialize(writer, "NewWorkspace", options);
                return;
            case TypeEnum.NotificationSchema:
                JsonSerializer.Serialize(writer, "NotificationSchema", options);
                return;
            case TypeEnum.Promote:
                JsonSerializer.Serialize(writer, "Promote", options);
                return;
            case TypeEnum.PromoteFocus:
                JsonSerializer.Serialize(writer, "PromoteFocus", options);
                return;
            case TypeEnum.PromoteWindow:
                JsonSerializer.Serialize(writer, "PromoteWindow", options);
                return;
            case TypeEnum.Query:
                JsonSerializer.Serialize(writer, "Query", options);
                return;
            case TypeEnum.QuickLoad:
                JsonSerializer.Serialize(writer, "QuickLoad", options);
                return;
            case TypeEnum.QuickSave:
                JsonSerializer.Serialize(writer, "QuickSave", options);
                return;
            case TypeEnum.Raise:
                JsonSerializer.Serialize(writer, "Raise", options);
                return;
            case TypeEnum.ReloadConfiguration:
                JsonSerializer.Serialize(writer, "ReloadConfiguration", options);
                return;
            case TypeEnum.ReloadStaticConfiguration:
                JsonSerializer.Serialize(writer, "ReloadStaticConfiguration", options);
                return;
            case TypeEnum.RemoveSubscriberPipe:
                JsonSerializer.Serialize(writer, "RemoveSubscriberPipe", options);
                return;
            case TypeEnum.RemoveSubscriberSocket:
                JsonSerializer.Serialize(writer, "RemoveSubscriberSocket", options);
                return;
            case TypeEnum.RemoveTitleBar:
                JsonSerializer.Serialize(writer, "RemoveTitleBar", options);
                return;
            case TypeEnum.ResizeDelta:
                JsonSerializer.Serialize(writer, "ResizeDelta", options);
                return;
            case TypeEnum.ResizeWindowAxis:
                JsonSerializer.Serialize(writer, "ResizeWindowAxis", options);
                return;
            case TypeEnum.ResizeWindowEdge:
                JsonSerializer.Serialize(writer, "ResizeWindowEdge", options);
                return;
            case TypeEnum.Retile:
                JsonSerializer.Serialize(writer, "Retile", options);
                return;
            case TypeEnum.Save:
                JsonSerializer.Serialize(writer, "Save", options);
                return;
            case TypeEnum.SendContainerToMonitorNumber:
                JsonSerializer.Serialize(writer, "SendContainerToMonitorNumber", options);
                return;
            case TypeEnum.SendContainerToMonitorWorkspaceNumber:
                JsonSerializer.Serialize(writer, "SendContainerToMonitorWorkspaceNumber", options);
                return;
            case TypeEnum.SendContainerToNamedWorkspace:
                JsonSerializer.Serialize(writer, "SendContainerToNamedWorkspace", options);
                return;
            case TypeEnum.SendContainerToWorkspaceNumber:
                JsonSerializer.Serialize(writer, "SendContainerToWorkspaceNumber", options);
                return;
            case TypeEnum.Show:
                JsonSerializer.Serialize(writer, "Show", options);
                return;
            case TypeEnum.SocketSchema:
                JsonSerializer.Serialize(writer, "SocketSchema", options);
                return;
            case TypeEnum.StackAll:
                JsonSerializer.Serialize(writer, "StackAll", options);
                return;
            case TypeEnum.StackWindow:
                JsonSerializer.Serialize(writer, "StackWindow", options);
                return;
            case TypeEnum.StackbarBackgroundColour:
                JsonSerializer.Serialize(writer, "StackbarBackgroundColour", options);
                return;
            case TypeEnum.StackbarFocusedTextColour:
                JsonSerializer.Serialize(writer, "StackbarFocusedTextColour", options);
                return;
            case TypeEnum.StackbarHeight:
                JsonSerializer.Serialize(writer, "StackbarHeight", options);
                return;
            case TypeEnum.StackbarLabel:
                JsonSerializer.Serialize(writer, "StackbarLabel", options);
                return;
            case TypeEnum.StackbarMode:
                JsonSerializer.Serialize(writer, "StackbarMode", options);
                return;
            case TypeEnum.StackbarTabWidth:
                JsonSerializer.Serialize(writer, "StackbarTabWidth", options);
                return;
            case TypeEnum.StackbarUnfocusedTextColour:
                JsonSerializer.Serialize(writer, "StackbarUnfocusedTextColour", options);
                return;
            case TypeEnum.State:
                JsonSerializer.Serialize(writer, "State", options);
                return;
            case TypeEnum.StaticConfigSchema:
                JsonSerializer.Serialize(writer, "StaticConfigSchema", options);
                return;
            case TypeEnum.Stop:
                JsonSerializer.Serialize(writer, "Stop", options);
                return;
            case TypeEnum.SwapWorkspacesToMonitorNumber:
                JsonSerializer.Serialize(writer, "SwapWorkspacesToMonitorNumber", options);
                return;
            case TypeEnum.TitleUpdate:
                JsonSerializer.Serialize(writer, "TitleUpdate", options);
                return;
            case TypeEnum.ToggleCrossMonitorMoveBehaviour:
                JsonSerializer.Serialize(writer, "ToggleCrossMonitorMoveBehaviour", options);
                return;
            case TypeEnum.ToggleFloat:
                JsonSerializer.Serialize(writer, "ToggleFloat", options);
                return;
            case TypeEnum.ToggleFocusFollowsMouse:
                JsonSerializer.Serialize(writer, "ToggleFocusFollowsMouse", options);
                return;
            case TypeEnum.ToggleMaximize:
                JsonSerializer.Serialize(writer, "ToggleMaximize", options);
                return;
            case TypeEnum.ToggleMonocle:
                JsonSerializer.Serialize(writer, "ToggleMonocle", options);
                return;
            case TypeEnum.ToggleMouseFollowsFocus:
                JsonSerializer.Serialize(writer, "ToggleMouseFollowsFocus", options);
                return;
            case TypeEnum.TogglePause:
                JsonSerializer.Serialize(writer, "TogglePause", options);
                return;
            case TypeEnum.ToggleTiling:
                JsonSerializer.Serialize(writer, "ToggleTiling", options);
                return;
            case TypeEnum.ToggleTitleBars:
                JsonSerializer.Serialize(writer, "ToggleTitleBars", options);
                return;
            case TypeEnum.ToggleWindowContainerBehaviour:
                JsonSerializer.Serialize(writer, "ToggleWindowContainerBehaviour", options);
                return;
            case TypeEnum.Transparency:
                JsonSerializer.Serialize(writer, "Transparency", options);
                return;
            case TypeEnum.TransparencyAlpha:
                JsonSerializer.Serialize(writer, "TransparencyAlpha", options);
                return;
            case TypeEnum.Uncloak:
                JsonSerializer.Serialize(writer, "Uncloak", options);
                return;
            case TypeEnum.Unmanage:
                JsonSerializer.Serialize(writer, "Unmanage", options);
                return;
            case TypeEnum.UnmanageFocusedWindow:
                JsonSerializer.Serialize(writer, "UnmanageFocusedWindow", options);
                return;
            case TypeEnum.UnmanagedWindowOperationBehaviour:
                JsonSerializer.Serialize(writer, "UnmanagedWindowOperationBehaviour", options);
                return;
            case TypeEnum.UnstackAll:
                JsonSerializer.Serialize(writer, "UnstackAll", options);
                return;
            case TypeEnum.UnstackWindow:
                JsonSerializer.Serialize(writer, "UnstackWindow", options);
                return;
            case TypeEnum.VisibleWindows:
                JsonSerializer.Serialize(writer, "VisibleWindows", options);
                return;
            case TypeEnum.WatchConfiguration:
                JsonSerializer.Serialize(writer, "WatchConfiguration", options);
                return;
            case TypeEnum.WindowHidingBehaviour:
                JsonSerializer.Serialize(writer, "WindowHidingBehaviour", options);
                return;
            case TypeEnum.WorkAreaOffset:
                JsonSerializer.Serialize(writer, "WorkAreaOffset", options);
                return;
            case TypeEnum.WorkspaceLayout:
                JsonSerializer.Serialize(writer, "WorkspaceLayout", options);
                return;
            case TypeEnum.WorkspaceLayoutCustom:
                JsonSerializer.Serialize(writer, "WorkspaceLayoutCustom", options);
                return;
            case TypeEnum.WorkspaceLayoutCustomRule:
                JsonSerializer.Serialize(writer, "WorkspaceLayoutCustomRule", options);
                return;
            case TypeEnum.WorkspaceLayoutRule:
                JsonSerializer.Serialize(writer, "WorkspaceLayoutRule", options);
                return;
            case TypeEnum.WorkspaceName:
                JsonSerializer.Serialize(writer, "WorkspaceName", options);
                return;
            case TypeEnum.WorkspacePadding:
                JsonSerializer.Serialize(writer, "WorkspacePadding", options);
                return;
            case TypeEnum.WorkspaceRule:
                JsonSerializer.Serialize(writer, "WorkspaceRule", options);
                return;
            case TypeEnum.WorkspaceTiling:
                JsonSerializer.Serialize(writer, "WorkspaceTiling", options);
                return;
        }
        throw new Exception("Cannot marshal type TypeEnum");
    }

    public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
}

internal class MoveBehaviourConverter : JsonConverter<MoveBehaviour>
{
    public override bool CanConvert(Type t) => t == typeof(MoveBehaviour);

    public override MoveBehaviour Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "Insert":
                return MoveBehaviour.Insert;
            case "NoOp":
                return MoveBehaviour.NoOp;
            case "Swap":
                return MoveBehaviour.Swap;
        }
        throw new Exception("Cannot unmarshal type MoveBehaviour");
    }

    public override void Write(Utf8JsonWriter writer, MoveBehaviour value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case MoveBehaviour.Insert:
                JsonSerializer.Serialize(writer, "Insert", options);
                return;
            case MoveBehaviour.NoOp:
                JsonSerializer.Serialize(writer, "NoOp", options);
                return;
            case MoveBehaviour.Swap:
                JsonSerializer.Serialize(writer, "Swap", options);
                return;
        }
        throw new Exception("Cannot marshal type MoveBehaviour");
    }

    public static readonly MoveBehaviourConverter Singleton = new MoveBehaviourConverter();
}

internal class FocusFollowsMouseEnumConverter : JsonConverter<FocusFollowsMouseEnum>
{
    public override bool CanConvert(Type t) => t == typeof(FocusFollowsMouseEnum);

    public override FocusFollowsMouseEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "Komorebi":
                return FocusFollowsMouseEnum.Komorebi;
            case "Windows":
                return FocusFollowsMouseEnum.Windows;
        }
        throw new Exception("Cannot unmarshal type FocusFollowsMouseEnum");
    }

    public override void Write(Utf8JsonWriter writer, FocusFollowsMouseEnum value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case FocusFollowsMouseEnum.Komorebi:
                JsonSerializer.Serialize(writer, "Komorebi", options);
                return;
            case FocusFollowsMouseEnum.Windows:
                JsonSerializer.Serialize(writer, "Windows", options);
                return;
        }
        throw new Exception("Cannot marshal type FocusFollowsMouseEnum");
    }

    public static readonly FocusFollowsMouseEnumConverter Singleton = new FocusFollowsMouseEnumConverter();
}

internal class ColumnEnumConverter : JsonConverter<ColumnEnum>
{
    public override bool CanConvert(Type t) => t == typeof(ColumnEnum);

    public override ColumnEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "Primary":
                return ColumnEnum.Primary;
            case "Secondary":
                return ColumnEnum.Secondary;
            case "Tertiary":
                return ColumnEnum.Tertiary;
        }
        throw new Exception("Cannot unmarshal type ColumnEnum");
    }

    public override void Write(Utf8JsonWriter writer, ColumnEnum value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case ColumnEnum.Primary:
                JsonSerializer.Serialize(writer, "Primary", options);
                return;
            case ColumnEnum.Secondary:
                JsonSerializer.Serialize(writer, "Secondary", options);
                return;
            case ColumnEnum.Tertiary:
                JsonSerializer.Serialize(writer, "Tertiary", options);
                return;
        }
        throw new Exception("Cannot marshal type ColumnEnum");
    }

    public static readonly ColumnEnumConverter Singleton = new ColumnEnumConverter();
}

internal class ColumnSplitWithCapacityConverter : JsonConverter<ColumnSplitWithCapacity>
{
    public override bool CanConvert(Type t) => t == typeof(ColumnSplitWithCapacity);

    public override ColumnSplitWithCapacity Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.Null:
                return new ColumnSplitWithCapacity { };
            case JsonTokenType.String:
                var stringValue = reader.GetString();
                switch (stringValue)
                {
                    case "Horizontal":
                        return new ColumnSplitWithCapacity { Enum = ColumnSplit.Horizontal };
                    case "Vertical":
                        return new ColumnSplitWithCapacity { Enum = ColumnSplit.Vertical };
                }
                break;
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<ColumnWidth>(ref reader, options);
                return new ColumnSplitWithCapacity { ColumnWidth = objectValue };
        }
        throw new Exception("Cannot unmarshal type ColumnSplitWithCapacity");
    }

    public override void Write(Utf8JsonWriter writer, ColumnSplitWithCapacity value, JsonSerializerOptions options)
    {
        if (value.IsNull)
        {
            writer.WriteNullValue();
            return;
        }
        if (value.Enum != null)
        {
            switch (value.Enum)
            {
                case ColumnSplit.Horizontal:
                    JsonSerializer.Serialize(writer, "Horizontal", options);
                    return;
                case ColumnSplit.Vertical:
                    JsonSerializer.Serialize(writer, "Vertical", options);
                    return;
            }
        }
        if (value.ColumnWidth != null)
        {
            JsonSerializer.Serialize(writer, value.ColumnWidth, options);
            return;
        }
        throw new Exception("Cannot marshal type ColumnSplitWithCapacity");
    }

    public static readonly ColumnSplitWithCapacityConverter Singleton = new ColumnSplitWithCapacityConverter();
}

internal class ColumnSplitConverter : JsonConverter<ColumnSplit>
{
    public override bool CanConvert(Type t) => t == typeof(ColumnSplit);

    public override ColumnSplit Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "Horizontal":
                return ColumnSplit.Horizontal;
            case "Vertical":
                return ColumnSplit.Vertical;
        }
        throw new Exception("Cannot unmarshal type ColumnSplit");
    }

    public override void Write(Utf8JsonWriter writer, ColumnSplit value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case ColumnSplit.Horizontal:
                JsonSerializer.Serialize(writer, "Horizontal", options);
                return;
            case ColumnSplit.Vertical:
                JsonSerializer.Serialize(writer, "Vertical", options);
                return;
        }
        throw new Exception("Cannot marshal type ColumnSplit");
    }

    public static readonly ColumnSplitConverter Singleton = new ColumnSplitConverter();
}

internal class DefaultLayoutConverter : JsonConverter<DefaultLayout>
{
    public override bool CanConvert(Type t) => t == typeof(DefaultLayout);

    public override DefaultLayout Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "BSP":
                return DefaultLayout.BSP;
            case "Columns":
                return DefaultLayout.Columns;
            case "Grid":
                return DefaultLayout.Grid;
            case "HorizontalStack":
                return DefaultLayout.HorizontalStack;
            case "RightMainVerticalStack":
                return DefaultLayout.RightMainVerticalStack;
            case "Rows":
                return DefaultLayout.Rows;
            case "UltrawideVerticalStack":
                return DefaultLayout.UltrawideVerticalStack;
            case "VerticalStack":
                return DefaultLayout.VerticalStack;
        }
        throw new Exception("Cannot unmarshal type DefaultLayout");
    }

    public override void Write(Utf8JsonWriter writer, DefaultLayout value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case DefaultLayout.BSP:
                JsonSerializer.Serialize(writer, "BSP", options);
                return;
            case DefaultLayout.Columns:
                JsonSerializer.Serialize(writer, "Columns", options);
                return;
            case DefaultLayout.Grid:
                JsonSerializer.Serialize(writer, "Grid", options);
                return;
            case DefaultLayout.HorizontalStack:
                JsonSerializer.Serialize(writer, "HorizontalStack", options);
                return;
            case DefaultLayout.RightMainVerticalStack:
                JsonSerializer.Serialize(writer, "RightMainVerticalStack", options);
                return;
            case DefaultLayout.Rows:
                JsonSerializer.Serialize(writer, "Rows", options);
                return;
            case DefaultLayout.UltrawideVerticalStack:
                JsonSerializer.Serialize(writer, "UltrawideVerticalStack", options);
                return;
            case DefaultLayout.VerticalStack:
                JsonSerializer.Serialize(writer, "VerticalStack", options);
                return;
        }
        throw new Exception("Cannot marshal type DefaultLayout");
    }

    public static readonly DefaultLayoutConverter Singleton = new DefaultLayoutConverter();
}

internal class AxisConverter : JsonConverter<Axis>
{
    public override bool CanConvert(Type t) => t == typeof(Axis);

    public override Axis Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "Horizontal":
                return Axis.Horizontal;
            case "HorizontalAndVertical":
                return Axis.HorizontalAndVertical;
            case "Vertical":
                return Axis.Vertical;
        }
        throw new Exception("Cannot unmarshal type Axis");
    }

    public override void Write(Utf8JsonWriter writer, Axis value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case Axis.Horizontal:
                JsonSerializer.Serialize(writer, "Horizontal", options);
                return;
            case Axis.HorizontalAndVertical:
                JsonSerializer.Serialize(writer, "HorizontalAndVertical", options);
                return;
            case Axis.Vertical:
                JsonSerializer.Serialize(writer, "Vertical", options);
                return;
        }
        throw new Exception("Cannot marshal type Axis");
    }

    public static readonly AxisConverter Singleton = new AxisConverter();
}

internal class LayoutRuleElementConverter : JsonConverter<LayoutRuleElement>
{
    public override bool CanConvert(Type t) => t == typeof(LayoutRuleElement);

    public override LayoutRuleElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.Number:
                var integerValue = reader.GetInt64();
                return new LayoutRuleElement { Integer = integerValue };
            case JsonTokenType.StartObject:
                var objectValue = JsonSerializer.Deserialize<LayoutRuleClass>(ref reader, options);
                return new LayoutRuleElement { LayoutRuleClass = objectValue };
        }
        throw new Exception("Cannot unmarshal type LayoutRuleElement");
    }

    public override void Write(Utf8JsonWriter writer, LayoutRuleElement value, JsonSerializerOptions options)
    {
        if (value.Integer != null)
        {
            JsonSerializer.Serialize(writer, value.Integer.Value, options);
            return;
        }
        if (value.LayoutRuleClass != null)
        {
            JsonSerializer.Serialize(writer, value.LayoutRuleClass, options);
            return;
        }
        throw new Exception("Cannot marshal type LayoutRuleElement");
    }

    public static readonly LayoutRuleElementConverter Singleton = new LayoutRuleElementConverter();
}

internal class WindowContainerBehaviourConverter : JsonConverter<WindowContainerBehaviour>
{
    public override bool CanConvert(Type t) => t == typeof(WindowContainerBehaviour);

    public override WindowContainerBehaviour Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "Append":
                return WindowContainerBehaviour.Append;
            case "Create":
                return WindowContainerBehaviour.Create;
        }
        throw new Exception("Cannot unmarshal type WindowContainerBehaviour");
    }

    public override void Write(Utf8JsonWriter writer, WindowContainerBehaviour value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case WindowContainerBehaviour.Append:
                JsonSerializer.Serialize(writer, "Append", options);
                return;
            case WindowContainerBehaviour.Create:
                JsonSerializer.Serialize(writer, "Create", options);
                return;
        }
        throw new Exception("Cannot marshal type WindowContainerBehaviour");
    }

    public static readonly WindowContainerBehaviourConverter Singleton = new WindowContainerBehaviourConverter();
}

internal class OperationBehaviourConverter : JsonConverter<OperationBehaviour>
{
    public override bool CanConvert(Type t) => t == typeof(OperationBehaviour);

    public override OperationBehaviour Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        switch (value)
        {
            case "NoOp":
                return OperationBehaviour.NoOp;
            case "Op":
                return OperationBehaviour.Op;
        }
        throw new Exception("Cannot unmarshal type OperationBehaviour");
    }

    public override void Write(Utf8JsonWriter writer, OperationBehaviour value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case OperationBehaviour.NoOp:
                JsonSerializer.Serialize(writer, "NoOp", options);
                return;
            case OperationBehaviour.Op:
                JsonSerializer.Serialize(writer, "Op", options);
                return;
        }
        throw new Exception("Cannot marshal type OperationBehaviour");
    }

    public static readonly OperationBehaviourConverter Singleton = new OperationBehaviourConverter();
}

public class DateOnlyConverter : JsonConverter<DateOnly>
{
    private readonly string serializationFormat;
    public DateOnlyConverter() : this(null) { }

    public DateOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
    }

    public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return DateOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
}

public class TimeOnlyConverter : JsonConverter<TimeOnly>
{
    private readonly string serializationFormat;

    public TimeOnlyConverter() : this(null) { }

    public TimeOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
    }

    public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return TimeOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
}

internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
{
    public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

    private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

    private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
    private string? _dateTimeFormat;
    private CultureInfo? _culture;

    public DateTimeStyles DateTimeStyles
    {
        get => _dateTimeStyles;
        set => _dateTimeStyles = value;
    }

    public string? DateTimeFormat
    {
        get => _dateTimeFormat ?? string.Empty;
        set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
    }

    public CultureInfo Culture
    {
        get => _culture ?? CultureInfo.CurrentCulture;
        set => _culture = value;
    }

    public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
    {
        string text;


        if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
        {
            value = value.ToUniversalTime();
        }

        text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

        writer.WriteStringValue(text);
    }

    public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        string? dateText = reader.GetString();

        if (string.IsNullOrEmpty(dateText) == false)
        {
            if (!string.IsNullOrEmpty(_dateTimeFormat))
            {
                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
            }
            else
            {
                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
            }
        }
        else
        {
            return default(DateTimeOffset);
        }
    }


    public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
